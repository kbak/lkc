\documentclass{chi2009}
\usepackage{times}
\usepackage{url}
\usepackage{graphics}
\usepackage{color}
\usepackage[pdftex]{hyperref}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{booktabs}

\newcommand{\docTitle}{Improving Usability of the Linux Kernel Configuration Tools}
\newcommand{\docKeywords}{usability, linux, kernel, configuration}

\hypersetup{%
pdftitle={\docTitle},
pdfauthor={Kacper Bak},
pdfkeywords={\docKeywords},
bookmarksnumbered,
pdfstartview={FitH},
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black,
breaklinks=true,
}
\newcommand{\comment}[1]{}
\definecolor{Orange}{rgb}{1,0.5,0}
\newcommand{\todo}[1]{\textsf{\textbf{\textcolor{Orange}{[[#1]]}}}}

\pagenumbering{arabic}  % Arabic page numbers for submission.  Remove this line to eliminate page numbers for the camera ready copy

\begin{document}
% to make various LaTeX processors do the right thing with page size
\special{papersize=8.5in,11in}
\setlength{\paperheight}{11in}
\setlength{\paperwidth}{8.5in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

% use this command to override the default ACM copyright statement 
% (e.g. for preprints). Remove for camera ready copy.
\toappear{Submitted for CS 889 - Open Source Usability.}

\title{\docTitle}
\numberofauthors{2}
\author{
  \alignauthor Kacper Bak\\
    \affaddr{Generative Software Development Lab}\\
    \affaddr{University of Waterloo, Canada}\\
    \email{kbak@gsd.uwaterloo.ca}
  \alignauthor Karim Ali\\
    \affaddr{PLG Group}\\
    \affaddr{University of Waterloo, Canada}\\
    \email{karim@uwaterloo.ca}
}

\maketitle

\begin{abstract}
  Every submission should begin with an abstract of about 150 words,
followed by a set of keywords. The abstract and keywords should be
placed in the left column of the first page under the left half of the
title. The abstract should be a concise statement of the problem,
approach and conclusions of the work described.  It should clearly
state the paper's contribution to the field of HCI.
\end{abstract}

\keywords{\docKeywords} 

\category{H.5.2}{Information Interfaces and Presentation}{Miscellaneous}%[Optional sub-category]

\section{Introduction}

GNU/Linux is a free operating system with Linux as its kernel. The Linux kernel\footnote{Available at: \url{http://www.kernel.org/}} is a mature and very complex piece of software. It has been developed by thousands of programmers led by Linus Torvalds since 1991. The kernel supports many computer architectures, network protocols, thousands of drivers, and many debugging options.

% mention the router case; limited resources; dependencies

Structure of the kernel is very modular, so that each user can tailor it to her particular needs and specific hardware. Users upgrade their kernels mostly to improve stability, apply new bug-fixes, add functionality, and drivers. Sometimes it is necessary to upgrade kernel in an embedded system, such as network router. Recent research \cite{she:kernel:2010} showed that the whole kernel is composed of almost 5500 features, of which 89\% are user-selectable. Thus, the variation space is huge and the configuration process requires a broad computer knowledge. Users can configure kernel either by manually editing the \textsf{.config} file or by using some configuration tool (i.e. \textsf{menuconfig, xconfig, gconfig}). The first option is discouraged, because it is very error-prone due to lack of automated constraint validation/propagation. Using a configurator is a better solution, but it is still a laborious process.

\section{Problem}
All the configuration tools are front-ends built on top of a single engine called Linux Kernel Configurator (LKC). LKC analyzes kernel variability and supports users during the configuration stage. LKC uses internally the KConfig language to represent variability and dependencies among features. As several researchers \cite{sincero:lkc:2008,she:kernel:2010} showed, there is a direct correspondence between well-understood feature models and practically crafted variability model used by the Linux kernel. In contrast with formal feature models, LKC is not supported by any formal reasoning engine (e.g. SAT-solver). This is a serious problem, because users can unconsciously create wrong configurations while having no clue why a particular configuration does not work.

Many users complain about the lack of kernel autoconfiguration \cite{debian:config:2010,soft32:config:2007}, where LKC could detect current hardware and automatically choose relevant modules. The situation is slowly improving as developers added the \textsf{localmodconfig} target to Linux-2.6.32. The command detects current kernel configuration and applies the same options to the new kernel. It is a step ahead, but the tool is very simplistic and assumes that all the required modules are already loaded. For example, if a computer has built-in Bluetooth, but the module is not loaded, the new kernel will not support the Bluetooth device. Furthermore, the autoconfiguration script offers a very coarse level of options granularity, e.g. if a computer has one sound card, such as Intel HD Audio, the script will select all available sound card drivers and all Intel HD Audio modules. The autoconfiguration tool reads configuration of the running kernel instead of detecting the actual hardware, e.g. for a laptop with the Core Duo 2 processor, it selected 686 processor in the new kernel, because that processor is selected in the running kernel.

Linux kernel configurators are targeted to advanced users. Some kernel developers expressed opinion \cite{ADDREF} that kernel should be configured only by experienced users. While this statement might be true, there are still lots of Linux novice users who want to learn how to configure kernel or need to compile a particular driver. As of now, there are millions of web pages describing how to configure and compile the Linux kernel. Novice users are often overwhelmed by the number of available options and required knowledge. LKC offers no progressive-disclosure for them.

There are also minor issues with configurators usability, such as inaccurate searching in xconfig. It allows to search for features by their name or symbol, but searching ignores long text descriptions. These descriptions are for humans, so that they can learn about specific configuration options.

Another issue with xconfig is lack of good navigation when debug info is displayed. User can only move forward from one feature to the other, but cannot go back or see where the feature is located. It is especially annoying when a configuration option depends on another feature, but the feature cannot be easily located.

\section{Past Attempts}
Some of the above issues were already solved in 2002 when Eric S. Raymond presented the CML2 configuration system \cite{raymond:cml2:2000}. It allowed for effective reasoning on kernel feature model and also provided progressive-disclosure. There was a long debate and flame war about using that system \cite{kerneltrap:linux:2002}. Finally, it was rejected for various (sometimes silly) reasons, such as Eric S. Raymond's attitude, Python dependency, complexity, radically new design. Many developers preferred to introduce gradual updates instead of applying one big patch.

\section{Solution}
Many of the LKC shortcomings can be fixed incrementally, without throwing away the whole infrastructure. Perhaps the most significant part, but fairly invisible for an end user, is adding a formal reasoning engine, such as a SAT-solver. It would solve all the problems with constraints, dependencies, and choice propagation. A more visible part would be autoconfiguration, i.e. kernel is automatically tailored to currently running machine. This can be done separately from the SAT-solver, but without reliable choice propagation, some configurations cannot be automatically applied. Although current autoconfiguration works fairly well in simple cases, it still requires post configuration in a dedicated tool. Furthermore, progressive-disclosure would allow different groups of users to configure kernel in a simpler way. Progressive-disclosure can be done separately from the SAT-solver, but it would require a hand-crafted algorithm for showing and hiding configuration options. Finally, the minor issues are relatively small (in terms of code) user interface improvements, but they have impact on overall usability.

We believe that the proposed improvements would make the kernel configuration infrastructure more robust and easier to use. Many of the techniques are not tied to this specific project. The problem of effective product configuration is very common, but rarely solved, it is enough to mention package managers, feature model configurators or even tailoring medical messages to specific patients. The FOSS community could use the algorithms and ideas in any kind of software that has variability in it.

\section{Scope}

\subsection{Reasoning Engine}

We are going to use one of available SAT-solvers to reason upon kernel configurations. Although the KConfig language is much richer than propositional formulas, it is possible to translate KConfig to Boolean propositional logic \cite{she:kconfig:2010}. The SAT-solver will be injected into LKC to automatically resolve dependencies and detect inconsistencies. The engine will report problems to the user, but will not be responsible for resolving conflicts.

\subsection{Autoconfiguration}

\todo{we'd have to scope hardware detection to the most popular devices. Think about CPU, sound cards, memory cards, network devices, usb devices. It would be ok to ask user if he wants to enable support for certain non-detectable stuff, such as pendrives. Take a look at make localmodconfig.}

\subsection{Progressive Disclosure}

We plan on adding progressive disclosure to the LKC infrastructure and the xconfig tool. It will offer a different set of configuration options for each of three user profiles: beginner, advanced, hacker. Beginner is a home/office user who is mostly interested in multimedia, Internet, popular external devices. An advanced user will have access to all configuration options but will not see hidden features. Hacker will see all available configuration options.

\subsection{Searching in xconfig}

Searching will work in the same way as with feature names or symbols, but it will include long text descriptions.

\subsection{Navigation in xconfig}

As for navigation, we are going to add a browser-like functionality. It will allow user to move forward, backward and jump to specific feature in the feature hierarchy.

\section{Evaluation Plan}

An evaluation plan. For any project, you should indicate how you will evaluate your project and its value (or potential value) to the FOSS community.

\todo{Some end-study on users. Will ask them to configure kernel using old and improved tools. Any specific ideas?}

\section{Outline}
Table \ref{tab:outline} shows our project milestones until the end of the term.

\begin{table}[!h]
\centering
\begin{tabularx}{0.5\textwidth}{X c c}
\toprule
\textbf{Milestone} & \textbf{Start} & \textbf{End}\\ \midrule
Initial Proposal & May 27 & May 31\\
Final proposal & May 31 & June 14 \\
Searching & June 1 & June 2\\
Navigation & June 1 & June 4\\
Progressive Disclosure & June 3 & June 11\\
Reasoning Engine & June 7 & July 9\\
Autoconfiguration & June 13 & July 9\\
User Study & July 12 & July 14\\
Report and Blog Entry & July 15 & July 28\\
\bottomrule
\end{tabularx}
\caption{Project Milestones}
\label{tab:outline}
\end{table}


\section{Division of Labor}
Table \ref{tab:plan} shows our project tasks and the group member responsible for each task.

\begin{table}[!h]
\centering
\begin{tabularx}{0.5\textwidth}{X c c}
\toprule
\textbf{Task} & \textbf{Karim Ali} & \textbf{Kacper Bak}\\ \midrule
Searching & $\surd$ &\\
Navigation & & $\surd$\\
Progressive Disclosure & $\surd$ &\\
Reasoning Engine & & $\surd$\\
Autoconfiguration & $\surd$ &\\
User Study & $\surd$ & $\surd$\\
Report & $\surd$ & $\surd$\\
\bottomrule
\end{tabularx}
\caption{Project Tasks}
\label{tab:plan}
\end{table}

\section{Future Work}
% \todo{what do you think about creating a graphical tool that goes with you step by step and configures a kernel? basically you answer some questions, press next, and finally click install to install the new kernel. It might be appreciated by beginners. Is it too simplistic? would it be useful? it improves usability, but are there many users who need such a limited tool?}

\bibliographystyle{abbrv}
\bibliography{doc}

\end{document}
